package math3d;

/**
 * A 3-dimensional vector.
 * @author vanjac
 */
public class Vector3 {
    public static final Vector3 ZERO    = new Vector3(0, 0, 0);
    
    public static final Vector3 FORWARD = new Vector3(-1, 0, 0);
    public static final Vector3 BACK    = new Vector3(1, 0, 0);
    public static final Vector3 LEFT    = new Vector3(0, -1, 0);
    public static final Vector3 RIGHT   = new Vector3(0, 1, 0);
    public static final Vector3 DOWN    = new Vector3(0, 0, -1);
    public static final Vector3 UP      = new Vector3(0, 0, 1);
    
    private final double x;
    private final double y;
    private final double z;
    
    /**
     * Create a new Vector3 from the x, y, and z coordinates.
     * @param x the x coordinate
     * @param y the y coordinate
     * @param z the z coordinate
     */
    public Vector3(double x, double y, double z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    /**
     * Create a new Vector2 with all of the coordinates equal
     * @param n the value of the x, y, and z coordinates
     */
    public Vector3(double n) {
        x = n;
        y = n;
        z = n;
    }
    
    /**
     * Create a vector from an array. x should be at index 0, y at index 1, and
     * z at index 2.
     * @param a the array of coordinates
     */
    public Vector3(double[] a) {
        switch(a.length) {
            case 0:
                x = 0;
                y = 0;
                z = 0;
                break;
            case 1:
                x = a[0];
                y = 0;
                z = 0;
                break;
            case 2:
                x = a[0];
                y = a[1];
                z = 0;
                break;
            default:
                x = a[0];
                y = a[1];
                z = a[2];
                break;
        }
    }
    
    @Override
    public String toString() {
        return Double.toString(x) + ", " +
                Double.toString(y) + ", " +
                Double.toString(z);
    }
    
    @Override
    public boolean equals(Object o) {
        if(o == null)
            return false;
        if(!(o instanceof Vector3))
            return false;
        if(o == this)
            return true;
        
        Vector3 v = (Vector3)o;
        return getX() == v.getX()
                && getY() == v.getY()
                && getZ() == v.getZ();
    }
    
    /**
     * Check if all coordinates of this vector are 0.
     * @return true if this is a zero vector
     */
    public boolean isZero() {
        return getX() == 0 && getY() == 0 && getZ() == 0;
    }
    
    @Override
    public int hashCode() { //generated by NetBeans
        int hash = 5;
        hash = 17 * hash + (int) (Double.doubleToLongBits(this.x) ^ (Double.doubleToLongBits(this.x) >>> 32));
        hash = 17 * hash + (int) (Double.doubleToLongBits(this.y) ^ (Double.doubleToLongBits(this.y) >>> 32));
        hash = 17 * hash + (int) (Double.doubleToLongBits(this.z) ^ (Double.doubleToLongBits(this.z) >>> 32));
        return hash;
    }
    
    /**
     * Get an array representation of this vector, with the x coordinate at
     * index 0, the y coordinate at index 1, and the z coordinate at index 2.
     * @return an array representation of this vector
     */
    public double[] toArray() {
        return new double[] {x, y, z};
    }
    
    /**
     * Special version of toArray() for OpenGL. The x, y and z values are
     * rearranged.
     * @return an array representation of this vector, in the order y, z, x
     */
    public double[] toGlArray() {
        return new double[] {y, z, x};
    }
    
    public double getX() {
        return x;
    }
    
    public double getY() {
        return y;
    }
    
    public double getZ() {
        return z;
    }
    
    public Vector3 setX(double newX) {
        return new Vector3(newX, getY(), getZ());
    }
    
    public Vector3 setY(double newY) {
        return new Vector3(getX(), newY, getZ());
    }
    
    public Vector3 setZ(double newZ) {
        return new Vector3(getX(), getY(), newZ);
    }
    
    public Vector3 inverse() {
        return new Vector3(-getX(), -getY(), -getZ());
    }
    
    public Vector3 add(Vector3 v) {
        return new Vector3(
                getX() + v.getX(),
                getY() + v.getY(),
                getZ() + v.getZ()
        );
    }
    
    public Vector3 subtract(Vector3 v) {
        return new Vector3(
                getX() - v.getX(),
                getY() - v.getY(),
                getZ() - v.getZ()
        );
    }
    
    public Vector3 multiply(double n) {
        return new Vector3(getX() * n, getY() * n, getZ() * n);
    }
    
    public Vector3 divide(double n) {
        return new Vector3(getX() / n, getY() / n, getZ() / n);
    }
    
    /**
     * Returns the dot product of this vector and another vector
     * @param v the other vector
     * @return the dot product of the two
     */
    public double dot(Vector3 v) {
        return getX()*v.getX() + getY()*v.getY() + getZ()*v.getZ();
    }
    
    /**
     * Returns true if this vector is orthogonal (at a right angle to) another
     * vector.
     * @param v the other vector
     * @return true if the vectors are orthogonal
     */
    public boolean orthogonal(Vector3 v) {
        return dot(v) == 0;
    }
    
    /**
     * Returns the cross product of this vector and another vector
     * @param v the other vector
     * @return the cross product of the two
     */
    public Vector3 cross(Vector3 v) {
        double newX = getY() * v.getZ() - getZ() * v.getY();
        double newY = getZ() * v.getX() - getX() * v.getZ();
        double newZ = getX() * v.getY() - getY() * v.getX();
        return new Vector3(newX, newY, newZ);
    }
    
    /**
     * Computes the normal vector of a triangle, with vertices in counter-
     * clockwise order.
     * Use .inverse() on the output of this function to find the
     * opposite normal, assuming vertices are clockwise.
     * @param v1 point 1
     * @param v2 point 2
     * @param v3 point 3
     * @return the normal Direction3
     */
    public static Direction3 normal(Vector3 v1, Vector3 v2, Vector3 v3) {
        //v1 will be the "origin" of the triangle, all other vectors will be
        //calculated relative to that.
        Vector3 a = v2.subtract(v1);
        Vector3 b = v3.subtract(v1);
        
        //cross product returns a vector that is orthogonal to the input vectors
        Vector3 unit = a.cross(b);
        unit = unit.normalize();
        Direction3 dir = new Direction3(unit);
        
        return dir;
    }
    
    /**
     * Linear interpolation between this vector and another
     * @param v the other vector
     * @param amount amount to move between vectors. 0 returns this vector. 1
     * returns the other vector. 0.5 returns the halfway point. Somewhere in
     * between returns a vector in between the two.
     * @return a new vector between this vector and another
     */
    public Vector3 lerp(Vector3 v, double amount) {
        Vector3 difference = v.subtract(this);
        return add(difference.multiply(amount));
    }
    
    /** 
     * Get the magnitude or length of a vector
     * @return the magnitude of the vector
     */
    public double magnitude() {
        return Math.sqrt(magnitudeSquare());
    }
    
    /**
     * Get the square of the magnitude of a vector. This is a faster
     * calculation, and is useful when the actual values don't matter.
     * @return the squared magnitude of the vector
     */
    public double magnitudeSquare() {
        return getX()*getX() + getY()*getY() + getZ()*getZ();
    }
    
    /**
     * Return a new vector with the same direction and a different magnitude
     * @param magnitude the magnitude to set
     * @return a new vector with the specified magnitude
     */
    public Vector3 setMagnitude(double magnitude) {
        double current = magnitude();
        return multiply(magnitude / current);
    }
    
    /**
     * If the magnitude is greater than max, return a new vector with max as the
     * magnitude. Otherwise, return this vector
     * @param max the maximum magnitude
     * @return a vector with its magnitude limited
     */
    public Vector3 limitMagnitude(double max) {
        if(magnitudeSquare() > max*max) { //square for faster calculation
            return setMagnitude(max);
        }
        return this;
    }
    
    /**
     * Return a new, "unit vector" with the same direction and a magnitude of 1.
     * @return a unit vector
     */
    public Vector3 normalize() {
        return setMagnitude(1);
    }
    
    public Direction3 direction() {
        return new Direction3(normalize());
    }
    
    public double distanceTo(Vector3 v) {
        return v.subtract(this).magnitude();
    }
    
    public Direction3 directionTowards(Vector3 v) {
        return v.subtract(this).direction();
    }
    
    public Vector3 rotate(Rotation3 amount) {
        Vector3 v = this;

        // roll (x)
        Vector2 xRot = new Vector2(v.getY(), v.getZ());
        xRot = xRot.rotate(amount.getXRotation());
        v = new Vector3(v.getX(), xRot.getX(), xRot.getY());

        // pitch (y)
        Vector2 yRot = new Vector2(v.getX(), v.getZ());
        yRot = yRot.rotate(amount.getYRotation());
        v = new Vector3(yRot.getX(), v.getY(), yRot.getY());

        // yaw (z)
        Vector2 zRot = new Vector2(v.getX(), v.getY());
        zRot = zRot.rotate(amount.getZRotation());
        v = new Vector3(zRot.getX(), zRot.getY(), v.getZ());

        return v;
    }

    public Vector3 rotateAround(Rotation3 amount, Vector3 center) {
        return subtract(center).rotate(amount).add(center);
    }

    public Vector3 move(Rotation3 direction, Vector3 amount) {
        amount = amount.rotate(direction);
        return add(amount);
    }
}
