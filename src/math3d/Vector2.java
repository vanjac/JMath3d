package math3d;

/**
 * A 2-dimensional vector.
 * @author vanjac
 */
public class Vector2 {
    public static final Vector2 ZERO = new Vector2(0, 0);
    public static final Vector2 BASE_ROTATION = new Vector2(1, 0);
    
    public static final double CIRCLE = Math.PI*2;
    
    private final double x;
    private final double y;
    
    /**
     * Create a new Vector3 from the x, and y coordinates.
     * @param x the x coordinate
     * @param y the y coordinate
     */
    public Vector2(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    /**
     * Create a new Vector2 with all of the coordinates equal
     * @param n the value of both the x and y coordinates
     */
    public Vector2(double n) {
        x = n;
        y = n;
    }
    
    /**
     * Create a vector from an array. x should be at index 0, and y at index 1.
     * @param a the array of coordinates
     */
    public Vector2(double[] a) {
        switch(a.length) {
            case 0:
                x = 0;
                y = 0;
                break;
            case 1:
                x = a[0];
                y = 0;
                break;
            default:
                x = a[0];
                y = a[1];
                break;
        }
    }
    
    @Override
    public String toString() {
        return Double.toString(x) + ", " + Double.toString(y);
    }
    
    @Override
    public boolean equals(Object o) {
        if(o == null)
            return false;
        if(!(o instanceof Vector2))
            return false;
        if(o == this)
            return true;
        
        Vector2 v = (Vector2)o;
        return getX() == v.getX() && getY() == v.getY();
    }
    
    /**
     * Check if all coordinates of this vector are 0.
     * @return true if this is a zero vector
     */
    public boolean isZero() {
        return getX() == 0 && getY() == 0;
    }
    
    @Override
    public int hashCode() { //generated by NetBeans
        int hash = 3;
        hash = 13 * hash + (int) (Double.doubleToLongBits(this.x) ^ (Double.doubleToLongBits(this.x) >>> 32));
        hash = 13 * hash + (int) (Double.doubleToLongBits(this.y) ^ (Double.doubleToLongBits(this.y) >>> 32));
        return hash;
    }
    
    /**
     * Get an array representation of this vector, with the x coordinate at
     * index 0 and the y coordinate at index 1.
     * @return an array representation of this vector
     */
    public double[] toArray() {
        return new double[] {x, y};
    }
    
    public double getX() {
        return x;
    }
    
    public double getY() {
        return y;
    }
    
    public Vector2 setX(double newX) {
        return new Vector2(newX, getY());
    }
    
    public Vector2 setY(double newY) {
        return new Vector2(getX(), newY);
    }
    
    public Vector2 inverse() {
        return new Vector2(-getX(), -getY());
    }
    
    public Vector2 add(Vector2 v) {
        return new Vector2(getX() + v.getX(), getY() + v.getY());
    }
    
    public Vector2 subtract(Vector2 v) {
        return new Vector2(getX() - v.getX(), getY() - v.getY());
    }
    
    public Vector2 multiply(double n) {
        return new Vector2(getX() * n, getY() * n);
    }
    
    public Vector2 divide(double n) {
        return new Vector2(getX() / n, getY() / n);
    }
    
    /**
     * Returns the dot product of this vector and another vector
     * @param v the other vector
     * @return the dot product of the two
     */
    public double dot(Vector2 v) {
        return getX()*v.getX() + getY()*v.getY();
    }
    
    /**
     * Returns true if this vector is orthogonal (at a right angle to) another
     * vector.
     * @param v the other vector
     * @return true if the vectors are orthogonal
     */
    public boolean orthogonal(Vector2 v) {
        return dot(v) == 0;
    }
    
    /**
     * Linear interpolation between this vector and another
     * @param v the other vector
     * @param amount amount to move between vectors. 0 returns this vector. 1
     * returns the other vector. 0.5 returns the halfway point. Somewhere in
     * between returns a vector in between the two.
     * @return a new vector between this vector and another
     */
    public Vector2 lerp(Vector2 v, double amount) {
        Vector2 difference = v.subtract(this);
        return add(difference.multiply(amount));
    }
    
    /** 
     * Get the magnitude or length of a vector
     * @return the magnitude of the vector
     */
    public double magnitude() {
        return Math.sqrt(magnitudeSquare());
    }
    
    /**
     * Get the square of the magnitude of a vector. This is a faster
     * calculation, and is useful when the actual values don't matter.
     * @return the squared magnitude of the vector
     */
    public double magnitudeSquare() {
        return getX()*getX() + getY()*getY();
    }
    
    /**
     * Return a new vector with the same direction and a different magnitude
     * @param magnitude the magnitude to set
     * @return a new vector with the specified magnitude
     */
    public Vector2 setMagnitude(double magnitude) {
        double current = magnitude();
        return multiply(magnitude / current);
    }
    
    /**
     * If the magnitude is greater than max, return a new vector with max as the
     * magnitude. Otherwise, return this vector
     * @param max the maximum magnitude
     * @return a vector with its magnitude limited
     */
    public Vector2 limitMagnitude(double max) {
        if(magnitudeSquare() > max*max) { //square for faster calculation
            return setMagnitude(max);
        }
        return this;
    }
    
    /**
     * Return a new, "unit vector" with the same direction and a magnitude of 1.
     * @return a unit vector
     */
    public Vector2 normalize() {
        return setMagnitude(1);
    }
    
    public double direction() {
        if (getX() == 0) {
            if (getY() >= 0) {
                return Math.PI/2;
            } else {
                return CIRCLE - Math.PI/2;
            }
        }
        
        double n = Math.atan(getY() / getX());
        if (getX() < 0) {
            n = n - Math.PI;
        }
        
        n = fixRotation(n);
        return n;
    }
    
    /**
     * Limits a rotation to be between 0 and 2*pi.
     * @param rot the rotation to fix
     * @return a new, equivalent rotation between 0 and 2*pi.
     */
    public static double fixRotation(double rot) {
        if(rot < 0) {
            double circles = Math.ceil(-rot / CIRCLE);
            rot += circles * CIRCLE;
        }
        rot = rot % CIRCLE;
        return rot;
    }
    
    /**
     * Create a unit vector with the specified direction.
     * @param direction the direction of the vector
     * @return the new unit vector
     */
    public static Vector2 unitVector(double direction) {
        return BASE_ROTATION.rotate(direction);
    }
    
    /**
     * Find the angle between this vector and another.
     * @param v the other vector
     * @return the angle between the vectors, in radians
     */
    public double angleBetween(Vector2 v) {
        return Math.acos((this.dot(v) / (this.magnitude() * v.magnitude())));
    }
    
    public double distanceTo(Vector2 v) {
        double x1 = getX() - v.getX();
        double y1 = getY() - v.getY();

        return Math.sqrt(x1 * x1 + y1 * y1);
    }
    
    public double directionTowards(Vector2 v) {
        return v.subtract(this).direction();
    }
    
    public Vector2 rotate(double amount) {
        double sinX = Math.sin(amount);
        double cosX = Math.cos(amount);
        Vector2 v = new Vector2(
                getX() * cosX - getY() * sinX,
                getY() * cosX + getX() * sinX
        );
        return v;
    }
    
    public Vector2 rotateAround(double amount, Vector2 center) {
        return subtract(center).rotate(amount).add(center);
    }
    
    public Vector2 move(double direction, Vector2 amount) {
        amount = amount.rotate(direction);
        return add(amount);
    }
}
